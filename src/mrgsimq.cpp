// Copyright (C) 2013 - 2019  Metrum Research Group, LLC
//
// This file is part of mrgsolve.
//
// mrgsolve is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// mrgsolve is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with mrgsolve.  If not, see <http://www.gnu.org/licenses/>.


/**
 * @mainpage
 *
 * Documentation for `mrgsolve` `C++` code.
 *
 * To see functions available in the `mrgx` plugin, see the
 * `mrgx` module <a href="group__mrgx.html">here</a>.
 *
 *
 */

/**
 * @file mrgsimq.cpp
 *
 */



#include <boost/shared_ptr.hpp>
#include <boost/pointer_cast.hpp>
#include <string>
#include "mrgsolve.h"
#include "odeproblem.h"
#include "dataobject.h"
#include "RcppInclude.h"


#define CRUMP(a) throw Rcpp::exception(a,false)
#define REP(a)   Rcpp::Rcout << #a << std::endl;
#define nREP(a)  Rcpp::Rcout << a << std::endl;
#define say(a)   Rcpp::Rcout << a << std::endl;
#define __ALAG_POS -1200



/** Perform a simulation run.
 *
 * @param parin list of data and options for the simulation
 * @param inpar numeric parameter values
 * @param parnames parameter names
 * @param init numeric initial values
 * @param cmtnames compartment names
 * @param capture indices in capture vector to actually get
 * @param funs list of pointer addresses to model functions generated by
 * getNativeSymbolInfo()
 * @param data the main data set
 * @param OMEGA between-ID normal random effects
 * @param SIGMA within-ID normal random effects
 * @return list containing matrix of simulated data and a character vector of
 * tran names that may have been carried into the output
 *
 */
// [[Rcpp::export]]
Rcpp::NumericMatrix MRGSIMQ(const Rcpp::List parin,
                            const Rcpp::NumericVector& inpar,
                            const Rcpp::CharacterVector& parnames,
                            const Rcpp::NumericVector& init,
                            Rcpp::CharacterVector& cmtnames,
                            const Rcpp::IntegerVector& capture,
                            const Rcpp::List& funs,
                            const Rcpp::NumericMatrix& data,
                            Rcpp::NumericMatrix& OMEGA,
                            Rcpp::NumericMatrix& SIGMA,
                            Rcpp::Environment envir) {
  
  const int  recsort = Rcpp::as<int>    (parin["recsort"]);
  const double mindt = Rcpp::as<double> (parin["mindt"]);
  
  // Create data objects from data and idata
  dataobject dat(data,parnames);
  dat.map_uid();
  dat.locate_tran();
  
  // Number of individuals in the data set
  const int NID = dat.nid();
  
  unsigned int k = 0;
  unsigned int crow = 0;
  
  bool put_ev_first = false;
  bool addl_ev_first = true;
  
  switch (recsort) {
  case 1:
    break;
  case 2:
    put_ev_first = false;
    addl_ev_first = false;
    break;
  case 3:
    put_ev_first = true;
    addl_ev_first = true;
    break;
  case 4:
    put_ev_first = true;
    addl_ev_first = false;
    break;
  default:
    CRUMP("recsort must be 1, 2, 3, or 4.");
  }
  
  // Requested compartments
  Rcpp::IntegerVector request = parin["request"];
  const unsigned int nreq = request.size();
  
  // Captures
  const unsigned int n_capture  = capture.size()-1;
  
  // Create odeproblem object
  odeproblem *prob  = new odeproblem(inpar, init, funs, capture.at(0));
  prob->omega(OMEGA);
  prob->sigma(SIGMA);
  prob->copy_parin(parin);
  prob->pass_envir(&envir);
  const unsigned int neq = prob->neq();
  
  recstack a(NID);
  
  unsigned int obscount = 0;
  unsigned int evcount = 0;
  dat.get_records(a, NID, neq, obscount, evcount, false, false);
  
  bool obsaug = false;
  
  int nextpos = put_ev_first ?  (data.nrow() + 10) : -100;
  
  if((obscount == 0) || (obsaug)) {
    
    Rcpp::NumericVector stime = Rcpp::as<Rcpp::NumericVector>(parin["stime"]);
    
    size_t n = stime.size();
    
    std::vector<rec_ptr> observations;
    
    observations.reserve(n);
    
    for(size_t j = 0; j < n; ++j) {
      rec_ptr obs = NEWREC(stime[j],nextpos,true);
      observations.push_back(obs);
    }
    
    // We have to look up the design from the idata set
    for(recstack::iterator it = a.begin(); it != a.end(); ++it) {
      it->reserve((it->size() + n));
      for(size_t h=0; h < n; ++h) {
        it->push_back(observations[h]);
        ++obscount;
      } 
      std::sort(it->begin(), it->end(), CompRec());
    }
  }
  
  // Create results matrix:
  //  rows: ntime*nset
  //  cols: rep, time, eq[0], eq[1], ..., yout[0], yout[1],...
  const unsigned int NN =  (obscount + evcount);
  int precol = 2;
  const unsigned int n_out_col  = precol + nreq + n_capture;
  Rcpp::NumericMatrix ans(NN,n_out_col);
  // const unsigned int tran_carry_start = precol;
  // const unsigned int data_carry_start = tran_carry_start;
  // const unsigned int idata_carry_start = data_carry_start;
  // const unsigned int req_start = idata_carry_start;
  const unsigned int req_start = precol;
  const unsigned int capture_start = req_start + nreq;
  
  const unsigned int neta = OMEGA.nrow();
  arma::mat eta;
  if(neta > 0) {
    eta = prob->mv_omega(NID);
    prob->neta(neta);
  }
  
  const unsigned int neps = SIGMA.nrow();
  arma::mat eps;
  if(neps > 0) {
    eps = prob->mv_sigma(NN);
    prob->neps(neps);
  }
  
  double tto, tfrom;
  crow = 0;
  int this_cmtn = 0;
  double dt = 0;
  double id = 0;
  double maxtime = 0;
  double Fn = 1.0;
  
  prob->nid(dat.nid());
  prob->nrow(NN);
  prob->idn(0);
  prob->rown(0);
  
  prob->config_call();
  reclist mtimehx;
  // i is indexing the subject, j is the record
  
  // LOOP ACROSS IDS:
  // tgrid observations have generic ID
  // We must first figure out the ID we are working with
  // and assign in the object
  for(size_t i=0; i < a.size(); ++i) {

    prob->idn(i);
    
    tfrom = a[i].front()->time();
    maxtime = a[i].back()->time();
    
    id = dat.get_uid(i);
    
    prob->reset_newid(id);
    
    if(i==0) {
      prob->newind(0);
    }
    
    for(k=0; k < neta; ++k) prob->eta(k,eta(i,k));
    for(k=0; k < neps; ++k) prob->eps(k,eps(crow,k));
    
    if(a[i][0]->from_data()) {
      dat.copy_parameters(a[i][0]->pos(), prob);
    }
    
    prob->y_init(init);
    
    prob->set_d(a[i][0]);
    prob->init_call(tfrom);
    
    for(size_t j=0; j < a[i].size(); ++j) {
      
      if(crow == NN) continue;
      
      prob->rown(crow);
      
      rec_ptr this_rec = a[i][j];
      
      this_rec->id(id);
      
      if(prob->systemoff()) {
        unsigned short int status = prob->systemoff();
        if(status==9) CRUMP("the problem was stopped at user request.");
        if(status==999) CRUMP("999 sent from the model");
        if(this_rec->output()) {
          if(status==1) {
            ans(crow,0) = this_rec->id();
            ans(crow,1) = this_rec->time();
            for(unsigned int k=0; k < n_capture; ++k) {
              ans(crow,(k+capture_start)) = prob->capture(capture[k+1]);
            }
            for(unsigned int k=0; k < nreq; ++k) {
              ans(crow,(k+req_start)) = prob->y(request[k]);
            }
          } else {
            for(int k=0; k < ans.ncol(); ++k) {
              ans(crow,k) = NA_REAL;
            }
          }
          ++crow;
        }
        continue;
      }
      
      if(this_rec->from_data()) {
        dat.copy_parameters(this_rec->pos(), prob);
      }
      
      tto = this_rec->time();
      
      dt  = (tto-tfrom)/(tfrom == 0.0 ? 1.0 : tfrom);
      
      if((dt > 0.0) && (dt < mindt)) {
        tto = tfrom;
      }
      
      if(tto > tfrom) {
        for(k = 0; k < neps; ++k) {
          prob->eps(k,eps(crow,k));
        }
      }
      
      if(j != 0) {
        prob->newind(2);
        prob->set_d(this_rec);
        prob->init_call_record(tto);
      }
      
      
      // Some non-observation event happening
      if(this_rec->is_event()) {
        
        this_cmtn = this_rec->cmtn();
        
        Fn = prob->fbio(this_cmtn);
        
        if(Fn < 0) {
          CRUMP("mrgsolve: bioavailability fraction is less than zero.");
        }
        
        bool sort_recs = false;
        
        if(this_rec->from_data()) {
          
          if(this_rec->rate() < 0) {
            prob->rate_main(this_rec);
          }
          
          if(prob->alag(this_cmtn) > mindt) { // there is a valid lagtime
            if(this_rec->ss() > 0) {
              this_rec->steady(prob, Fn);
            }
            rec_ptr newev = NEWREC(*this_rec);
            newev->pos(__ALAG_POS);
            newev->phantom_rec();
            newev->time(this_rec->time() + prob->alag(this_cmtn));
            newev->ss(0);
            reclist::iterator it = a[i].begin()+j;
            advance(it,1);
            a[i].insert(it,newev);
            newev->schedule(a[i], maxtime, addl_ev_first, Fn);
            this_rec->unarm();
            sort_recs = true;
          } else { // no valid lagtime
            this_rec->schedule(a[i], maxtime, addl_ev_first, Fn);
            sort_recs = this_rec->needs_sorting();
          }
        } // from data
        
        // This block gets hit for any and all infusions; sometimes the
        // infusion just got started and we need to add the lag time
        // sometimes it is an infusion via addl and lag time is already there
        if(this_rec->int_infusion() && this_rec->armed()) {
          rec_ptr evoff = NEWREC(this_rec->cmt(),
                                 9,
                                 this_rec->amt(),
                                 this_rec->time() + this_rec->dur(Fn),
                                 this_rec->rate(),
                                 -299,
                                 this_rec->id());
          if(this_rec->from_data()) {
            evoff->time(evoff->time() + prob->alag(this_cmtn));
          }
          a[i].push_back(evoff);
          sort_recs = true;
        }
        
        // SORT
        if(sort_recs) {
          std::sort(a[i].begin()+j+1,a[i].end(),CompRec());
        }
      } // is_dose
      
      prob->advance(tfrom,tto);
      
      if(this_rec->evid() != 2) {
        this_rec->implement(prob);
      }
      
      prob->table_call();
      
      if(prob->any_mtime()) {
        if(prob->newind() <=1) mtimehx.clear();  
        std::vector<mrgsolve::evdata> mt  = prob->mtimes();
        for(size_t mti = 0; mti < mt.size(); ++mti) {
          double this_time = (mt[mti]).time;
          if(this_time < tto) continue;
          unsigned int this_evid = (mt[mti]).evid;
          double this_amt = mt[mti].amt;
          int this_cmt = (mt[mti]).cmt;
          if(neq!=0 && this_evid !=0) {
            if((this_cmt == 0) || (abs(this_cmt) > int(neq))) {
              Rcpp::Rcout << this_cmt << std::endl;
              CRUMP("Compartment number in modeled event out of range.");
            }
          }
          rec_ptr new_ev = NEWREC(this_cmt,this_evid,this_amt,this_time,0.0);
          new_ev->phantom_rec();
          if(mt[mti].now) {
            new_ev->implement(prob);
          } else {
            bool foo = CompEqual(mtimehx,this_time,this_evid,this_cmt);
            if(!foo) {
              a[i].push_back(new_ev);
              std::sort(a[i].begin()+j+1,a[i].end(),CompRec());
              mtimehx.push_back(new_ev);
            } 
          }
        }
        prob->clear_mtime();
      }
      
      
      if(this_rec->output()) {
        ans(crow,0) = this_rec->id();
        ans(crow,1) = this_rec->time();
        
        k = 0;
        for(unsigned int i=0; i < n_capture; ++i) {
          ans(crow,k+capture_start) = prob->capture(capture[i+1]);
          ++k;
        }
        for(k=0; k < nreq; ++k) {
          ans(crow,(k+req_start)) = prob->y(request[k]);
        }
        ++crow;
      } 
      if(this_rec->evid()==2) {
        this_rec->implement(prob);
      }
      tfrom = tto;
    }
  }
  
  delete prob;
  return ans;
}
